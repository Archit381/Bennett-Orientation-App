var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import createPosed from 'react-pose-core';
import { getStylesFromPoser } from './inc/utils';
import pose from 'animated-pose';
import { Animated, PanResponder } from 'react-native';
import { warning } from 'hey-listen';
var posed = createPosed({
    componentMap: {
        View: Animated.View,
        Image: Animated.Image,
        Text: Animated.Text,
        ScrollView: Animated.ScrollView
    },
    poseFactory: pose,
    getStylesFromPoser: getStylesFromPoser,
    createAnimatedComponent: function (Component) {
        return Animated.createAnimatedComponent(Component);
    },
    filterConfig: function (_a) {
        var draggable = _a.draggable, config = __rest(_a, ["draggable"]);
        return config;
    },
    transformConfig: function (config) {
        var draggable = config.draggable;
        if (!draggable)
            return;
        config._drag = { x: 0, y: 0 };
        config.props = __assign({}, config.props, { useNativeDriver: false });
    },
    getProps: function (poser, _a, _b, setLayout) {
        var draggable = _a.draggable;
        var onDragStart = _b.onDragStart, onDragEnd = _b.onDragEnd, flipMove = _b.flipMove, measureSelf = _b.measureSelf;
        var props = {};
        if (draggable) {
            warning(false, 'draggable: true disables useNativeDriver for this component.');
            var values_1 = poser.get();
            var dragX_1 = draggable === true || draggable === 'x';
            var dragY_1 = draggable === true || draggable === 'y';
            var panResponder = PanResponder.create({
                onMoveShouldSetPanResponderCapture: function () { return true; },
                onPanResponderMove: Animated.event([
                    null,
                    {
                        dx: dragX_1 ? values_1.x : null,
                        dy: dragY_1 ? values_1.y : null
                    }
                ]),
                onPanResponderGrant: function (e, gestureState) {
                    if (dragX_1) {
                        values_1.x.setOffset(values_1.x._value);
                        values_1.x.setValue(0);
                    }
                    if (dragY_1) {
                        values_1.y.setOffset(values_1.y._value);
                        values_1.y.setValue(0);
                    }
                    if (onDragStart)
                        onDragStart(e, gestureState);
                    poser.set('dragging', { gestureState: gestureState });
                },
                onPanResponderRelease: function (e, gestureState) {
                    if (onDragEnd)
                        onDragEnd(e, gestureState);
                    if (dragX_1)
                        values_1.x.flattenOffset();
                    if (dragY_1)
                        values_1.y.flattenOffset();
                    poser.set('dragEnd', { gestureState: gestureState });
                }
            });
            props = __assign({}, props, panResponder.panHandlers);
        }
        if (flipMove || measureSelf) {
            props.onLayout = function (_a) {
                var nativeEvent = _a.nativeEvent;
                return setLayout(nativeEvent.layout);
            };
        }
        return props;
    }
});
export default posed;
//# sourceMappingURL=posed.js.map