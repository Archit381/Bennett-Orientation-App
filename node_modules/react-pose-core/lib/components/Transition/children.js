var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import { Children, cloneElement } from 'react';
import { invariant } from 'hey-listen';
var getKey = function (child) {
    invariant(child && child.key !== null, 'Every child of Transition must be given a unique key');
    var childKey = typeof child.key === 'number' ? child.key.toString() : child.key;
    return childKey.replace('.$', '');
};
var getKeys = function (children) {
    return Children.toArray(children)
        .filter(Boolean)
        .map(getKey);
};
var handleTransition = function (_a, _b) {
    var displayedChildren = _b.children, leaving = _b.leaving, scheduleChildRemoval = _b.scheduleChildRemoval, hasMounted = _b.hasMounted;
    var targetChildren = _a.children, preEnterPose = _a.preEnterPose, enterPose = _a.enterPose, exitPose = _a.exitPose, animateOnMount = _a.animateOnMount, enterAfterExit = _a.enterAfterExit, popFromLayoutOnExit = _a.popFromLayoutOnExit, flipMove = _a.flipMove, props = __rest(_a, ["children", "preEnterPose", "enterPose", "exitPose", "animateOnMount", "enterAfterExit", "popFromLayoutOnExit", "flipMove"]);
    var displayedKeys = getKeys(displayedChildren);
    var targetKeys = getKeys(targetChildren);
    var enteringKeys = new Set(targetKeys.filter(function (key) {
        var isEntering = displayedKeys.indexOf(key) === -1 || leaving[key] === false;
        if (isEntering)
            delete leaving[key];
        return isEntering;
    }));
    var leavingKeys = displayedKeys.filter(function (key) { return targetKeys.indexOf(key) === -1; });
    var children = [];
    Children.forEach(targetChildren, function (child) {
        if (!child)
            return;
        var isEntering = enteringKeys.has(getKey(child));
        var baseProps = {
            flipMove: flipMove,
            measureSelf: popFromLayoutOnExit
        };
        if (isEntering && (enterAfterExit && leavingKeys.length))
            return;
        var cloneProps = isEntering
            ? __assign({ initialPose: animateOnMount || hasMounted ? preEnterPose : undefined, pose: enterPose, onPoseComplete: null }, baseProps, props) : __assign({}, baseProps, props);
        children.push(cloneElement(child, cloneProps));
    });
    leavingKeys.forEach(function (key) {
        leaving[key] = false;
        var child = displayedChildren.find(function (c) { return getKey(c) === key; });
        var newChild = cloneElement(child, __assign({ pose: exitPose, onPoseComplete: function (pose) {
                scheduleChildRemoval(key);
                var onPoseComplete = child.props.onPoseComplete;
                onPoseComplete && onPoseComplete(pose);
            }, popFromLayout: popFromLayoutOnExit || flipMove }, props));
        var insertionIndex = displayedKeys.indexOf(key);
        children.splice(insertionIndex, 0, newChild);
    });
    return { children: children };
};
export default (function (props, state) { return (__assign({ hasMounted: true }, handleTransition(props, state))); });
//# sourceMappingURL=children.js.map