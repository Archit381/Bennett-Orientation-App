var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import { Animated } from 'react-native';
import poseFactory from 'pose-core';
import { warning } from 'hey-listen';
import defaultTransitions from './inc/default-transitions';
import { getUnit } from './inc/unit-conversion';
import convertTransitionDefinition from './inc/convert-transition-definition';
var FLIP_TO_ORIGIN = 'flipToOrigin';
var nonLayoutValues = new Set([
    'x',
    'y',
    'z',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skewX',
    'skewY',
    'skewZ',
    'opacity'
]);
var isAction = function (action) {
    return typeof action.start !== 'undefined';
};
export default (function (_a) {
    var convertUnitToPoints = _a.convertUnitToPoints, unitConverters = _a.unitConverters;
    var pose = poseFactory({
        bindOnChange: function (values, onChange) { return function (key) {
            if (!values.has(key))
                return;
            var raw = values.get(key).raw;
            if (raw)
                raw.addListener(onChange[key]);
        }; },
        readValue: function () { return 0; },
        readValueFromSource: function (key) {
            if (key.includes('rotate'))
                return '0deg';
            if (key.includes('scale'))
                return 1;
            return 0;
        },
        convertValue: function (raw, key) { return ({
            raw: raw,
            useNativeDriver: nonLayoutValues.has(key)
        }); },
        createValue: function (init, key, props, _a) {
            var _b = _a === void 0 ? {} : _a, passiveParent = _b.passiveParent, passiveProps = _b.passiveProps, passiveParentKey = _b.passiveParentKey;
            if (passiveParent) {
                if (!nonLayoutValues.has(key)) {
                    passiveParent.useNativeDriver = props.useNativeDriver = false;
                    warning(false, "useNativeDriver is invalidated on value \"" + passiveParentKey + "\", because interpolated value \"" + key + "\" can't be animated by the native driver.");
                }
                return {
                    interpolation: passiveParent.raw.interpolate(passiveProps)
                };
            }
            else {
                var needsInterpolation = false;
                var unit = '';
                var initValue = 0;
                if (typeof init === 'string') {
                    unit = getUnit(init);
                    initValue = parseFloat(init);
                    if (unitConverters[unit]) {
                        initValue = convertUnitToPoints(init);
                    }
                    else {
                        needsInterpolation = true;
                    }
                }
                else {
                    initValue = init;
                }
                var value = {
                    raw: new Animated.Value(initValue),
                    useNativeDriver: nonLayoutValues.has(key)
                };
                if (needsInterpolation) {
                    value.interpolation = value.raw.interpolate({
                        inputRange: [0, 1],
                        outputRange: ["0" + unit, "1" + unit]
                    });
                }
                return value;
            }
        },
        getTransitionProps: function (_a, toValue, props) {
            var raw = _a.raw, useNativeDriver = _a.useNativeDriver;
            return ({
                value: raw,
                useNativeDriver: props.useNativeDriver === false ? false : useNativeDriver,
                toValue: toValue
            });
        },
        convertTransitionDefinition: function (_a, def, _b) {
            var raw = _a.raw, useNativeDriver = _a.useNativeDriver;
            var toValue = _b.toValue;
            return isAction(def)
                ? def
                : convertTransitionDefinition(raw, __assign({}, def, { useNativeDriver: useNativeDriver,
                    toValue: toValue }));
        },
        resolveTarget: function (_a, target) {
            var interpolation = _a.interpolation;
            if (interpolation)
                return parseFloat(target);
            if (typeof target === 'number')
                return target;
            return convertUnitToPoints(target);
        },
        selectValueToRead: function (_a) {
            var raw = _a.raw, interpolation = _a.interpolation;
            return interpolation || raw;
        },
        startAction: function (value, action, onComplete) {
            action.start(onComplete);
            return action;
        },
        stopAction: function (action) { return action.stop(); },
        getInstantTransition: function (_a, _b) {
            var raw = _a.raw, useNativeDriver = _a.useNativeDriver;
            var toValue = _b.toValue;
            return Animated.timing(raw, {
                toValue: toValue,
                duration: 0,
                useNativeDriver: useNativeDriver
            });
        },
        addActionDelay: function (delay, transition) {
            if (delay === void 0) { delay = 0; }
            return Animated.sequence([Animated.delay(delay), transition]);
        },
        defaultTransitions: defaultTransitions,
        setValue: function (_a, val) {
            var raw = _a.raw;
            return raw.setValue(val);
        },
        setValueNative: function () { return undefined; },
        transformPose: function (enteringPose, name, _a) {
            var props = _a.props;
            if (name === FLIP_TO_ORIGIN) {
                var flipPose = __assign({}, enteringPose);
                if (props.xDelta)
                    flipPose.x = 0;
                if (props.yDelta)
                    flipPose.y = 0;
            }
            return enteringPose;
        },
        extendAPI: function (api, _a) {
            var values = _a.values;
            return (__assign({}, api, { addChild: function (config) { return api._addChild(config, pose); }, flip: function (_a, _b) {
                    var fromX = _a.x, fromY = _a.y;
                    var toX = _b.x, toY = _b.y;
                    var xDelta = fromX - toX;
                    var yDelta = fromY - toY;
                    var hasMoved = xDelta || yDelta;
                    values.get('x').raw.setValue(xDelta);
                    values.get('y').raw.setValue(yDelta);
                    if (hasMoved) {
                        api.setProps({ xDelta: xDelta, yDelta: yDelta });
                        api.set(FLIP_TO_ORIGIN);
                    }
                } }));
        }
    });
    var parseConfig = function (_a) {
        var flipEnabled = _a.flipEnabled, config = __rest(_a, ["flipEnabled"]);
        if (flipEnabled) {
            config[FLIP_TO_ORIGIN] = __assign({}, config[FLIP_TO_ORIGIN], { x: 0, y: 0 });
        }
        return config;
    };
    return function (config) { return pose(parseConfig(config)); };
});
//# sourceMappingURL=factory.js.map